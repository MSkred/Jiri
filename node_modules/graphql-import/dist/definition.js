"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var builtinTypes = ['String', 'Float', 'Int', 'Boolean', 'ID'];
function completeDefinitionPool(allDefinitions, defintionPool, newTypeDefinitions, schemaPath) {
    var visitedDefinitions = {};
    while (newTypeDefinitions.length > 0) {
        var schemaMap = lodash_1.keyBy(allDefinitions, function (d) { return d.name.value; });
        var newDefinition = newTypeDefinitions.shift();
        if (visitedDefinitions[newDefinition.name.value]) {
            continue;
        }
        var collectedTypedDefinitions = collectNewTypeDefinitions(allDefinitions, defintionPool, newDefinition, schemaMap, schemaPath);
        newTypeDefinitions.push.apply(newTypeDefinitions, collectedTypedDefinitions);
        defintionPool.push.apply(defintionPool, collectedTypedDefinitions);
        visitedDefinitions[newDefinition.name.value] = true;
    }
    return lodash_1.uniqBy(defintionPool, 'name.value');
}
exports.completeDefinitionPool = completeDefinitionPool;
function collectNewTypeDefinitions(allDefinitions, definitionPool, newDefinition, schemaMap, schemaPath) {
    var newTypeDefinitions = [];
    if (newDefinition.kind === 'InputObjectTypeDefinition') {
        newDefinition.fields.forEach(function (field) {
            var namedType = getNamedType(field.type);
            var typeName = namedType.name.value;
            // collect missing argument input types
            if (!definitionPool.some(function (d) { return d.name.value === typeName; }) &&
                !builtinTypes.includes(typeName)) {
                var argTypeMatch = schemaMap[typeName];
                if (!argTypeMatch) {
                    throw new Error("Field " + field.name.value + ": Couldn't find type " + typeName + " in " + schemaPath + ".");
                }
                newTypeDefinitions.push(argTypeMatch);
            }
        });
    }
    if (newDefinition.kind === 'InterfaceTypeDefinition') {
        var interfaceName_1 = newDefinition.name.value;
        newDefinition.fields.forEach(function (field) {
            var namedType = getNamedType(field.type);
            var typeName = namedType.name.value;
            if (!definitionPool.some(function (d) { return d.name.value === typeName; }) &&
                !builtinTypes.includes(typeName)) {
                var schemaType = schemaMap[typeName];
                if (!schemaType) {
                    throw new Error("Field " + field.name.value + ": Couldn't find type " + typeName + " in " + schemaPath + ".");
                }
                newTypeDefinitions.push(schemaType);
            }
        });
        var interfaceImplementations = allDefinitions.filter(function (d) {
            return d.kind === 'ObjectTypeDefinition' &&
                d.interfaces.some(function (i) { return i.name.value === interfaceName_1; });
        });
        newTypeDefinitions.push.apply(newTypeDefinitions, interfaceImplementations);
    }
    if (newDefinition.kind === 'UnionTypeDefinition') {
        newDefinition.types.forEach(function (type) {
            if (!definitionPool.some(function (d) { return d.name.value === type.name.value; })) {
                var typeName = type.name.value;
                var typeMatch = schemaMap[typeName];
                if (!typeMatch) {
                    throw new Error("Couldn't find type " + typeName + " in " + schemaPath + ".");
                }
                newTypeDefinitions.push(schemaMap[type.name.value]);
            }
        });
    }
    if (newDefinition.kind === 'ObjectTypeDefinition') {
        // collect missing interfaces
        newDefinition.interfaces.forEach(function (int) {
            if (!definitionPool.some(function (d) { return d.name.value === int.name.value; })) {
                var interfaceName = int.name.value;
                var interfaceMatch = schemaMap[interfaceName];
                if (!interfaceMatch) {
                    throw new Error("Couldn't find interface " + interfaceName + " in " + schemaPath + ".");
                }
                newTypeDefinitions.push(schemaMap[int.name.value]);
            }
        });
        // iterate over all fields
        newDefinition.fields.forEach(function (field) {
            var namedType = getNamedType(field.type);
            var typeName = namedType.name.value;
            // collect missing argument input types
            field.arguments.forEach(function (argument) {
                var argType = getNamedType(argument.type);
                var argTypeName = argType.name.value;
                if (!definitionPool.some(function (d) { return d.name.value === argTypeName; }) &&
                    !builtinTypes.includes(argTypeName)) {
                    var argTypeMatch = schemaMap[argTypeName];
                    if (!argTypeMatch) {
                        throw new Error("Field " + field.name.value + ": Couldn't find type " + argTypeName + " in " + schemaPath + ".");
                    }
                    newTypeDefinitions.push(argTypeMatch);
                }
            });
            // collect missing field types
            if (!definitionPool.some(function (d) { return d.name.value === typeName; }) &&
                !builtinTypes.includes(typeName)) {
                var schemaType = schemaMap[typeName];
                if (!schemaType) {
                    throw new Error("Field " + field.name.value + ": Couldn't find type " + typeName + " in " + schemaPath + ".");
                }
                newTypeDefinitions.push(schemaType);
            }
        });
    }
    return newTypeDefinitions;
}
function getNamedType(type) {
    if (type.kind === 'NamedType') {
        return type;
    }
    else {
        return getNamedType(type.type);
    }
}
//# sourceMappingURL=definition.js.map